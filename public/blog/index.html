
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Andre Fonseca</title>
  <meta name="author" content="Andre Fonseca">

  
  <meta name="description" content="Na empresa onde trabalho, Globo.com, todo início de ano temos que &ldquo;escolher&rdquo; para quais eventos gostaríamos de ir. Esses eventos podem &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andrefonseca.net/blog">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Andre Fonseca" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34644487-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner">
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:andrefonseca.net" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/19/pesquisa-sobre-eventos-de-ti/">Pesquisa Sobre Os Eventos De TI</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-19T09:48:32-03:00" pubdate data-updated="true">Mar 19<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/03/19/pesquisa-sobre-eventos-de-ti/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2014/03/19/pesquisa-sobre-eventos-de-ti/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Na empresa onde trabalho, Globo.com, todo início de ano temos que <em>&ldquo;escolher&rdquo;</em> para quais eventos gostaríamos de ir. Esses eventos podem ser no Brasil ou fora, sendo que devem falar sobre assuntos que tenham correlação com seu trabalho ou objetivo de seu time ou área. Diante disso, o que geralmente fazemos, é montar uma planilha com diversos eventos que vamos <em>encontrado</em>. Isso feito, escolhemos a partir dessa lista quais eventos desejamos ir seguindo algumas regras.</p>

<p>Nesse ano, conforme fomos levantando os eventos, acabou surgindo uma discussão quanto a <em>qualidade</em> dos eventos. Ao analisarmos as grades(temas, palestrantes, etc), eu e um grupo ficamos com a sensação ruim de estar vendo mais do mesmo, conteúdos rasos, <em>repetição de tutoriais</em>, e outras coisas similares.  Cheguei, inclusive, a postar essa impressão no meu facebook, onde tive um retorno similar de amigos de fora da Globo.com.</p>

<p>Diante disso, após mais um pouco de conversa, resolvi fazer uma pesquisa para ver o quanto essa percepção em relação a <em>qualidade</em> dos eventos era só minha, ou, de fato, há uma certo sentimento geral.</p>

<h2>A Pesquisa</h2>

<p>Para fazer a pesquisa, optei por um formulário simples no GoogleDocs, onde fiz algumas perguntas como: <em>Você se interessaria por eventos mais técnicos? Quais assuntos desejaria ver? Deixe seu comentário&hellip;</em></p>

<p>A intenção clara era de captar o nível de insastifação com relação as temas, formas, organização e nível dos conteúdos abordados. Outro ponto, é que o direcionamento também foi para pessoas com mais experiência.
Publicado o form, fiz um tweet e pedi ajuda a amigos para espalharem o formulário para alcançarmos o máximo de pessoas o possível.</p>

<h2>O Resultado</h2>

<p>Até o momento em que escrevo esse artigo, tinhamos por volta de 170 respostas. Embora não seja um número muito grande do ponto de vista estatistico &ndash; que nos permitiria ver alguma tendência, o grande ponto vou ver o quanto o sentimento de insastifação é compartilhado.</p>

<p>Isso ficou bem claro, nos comentários deixados pelo pessoal no final do formulário: esse de fato foi o campo mais revelador de toda a pesquisa.</p>

<p>Comentários como, <em>&ldquo;Muita panelinha &hellip;&rdquo;; &ldquo;Sempre os mesmos assuntos&hellip;&rdquo;; &ldquo;Coisas que poderia aprender com tutoriais&rdquo;</em>, surgiram em quantidade expressivas, revelando que precisamos repensar a forma que fazemos evento e montamos nossas grades.</p>

<p>Para exemplificar, na montagem do evento do <strong>Front in Rio 2013</strong>, nós da organização discutimos muito para saber qual seria a melhor forma de escolher as palestras. Acabamos por fim abrindo um pouco a grade e escolhendo pessoas que trouxeram <strong>assuntos</strong> (e não currículos) interessantes para a comunidade.</p>

<h2>Conclusão</h2>

<p>Frente aos dados que levantei, as opiniões e as discussões em cima de todo esse material que tive, a conclusão que chego é que existe espaço e demanda para eventos mais técnicos e de conteúdo mais aprofundado, porém, esses não pode ser no mesmo formato dos atuais, nem invalidam a importância dos mesmos.</p>

<p>Vamos por parte:</p>

<ul>
<li>Como disse um amigo, eventos grandes, ou para grande <em>massas</em>, eles tem que ser mais abrangentes, mais rasos e contar com pessoas conhecidas e <em>famosas</em> para atrair gente, pois esse é seu real objetivo: atrair pessoas para o meio. Famoso, chamar atenção.</li>
<li>Eventos mais técnicos não podem ser grandes pois isso inviabilizaria a discussão e troca&hellip; Não existe como conversar com 500 pessoas. Limites de 100 a 150 pessoas(ou até menos) parece-me ser a melhor opção.</li>
<li>As pessoas quando buscam por mais conteúdo querem que isso seja lhe entregue de uma forma bem mais flexível e <em>pessoal</em>.  Sendo assim, se quisermos eventos com mais qualidade técnica, esse modelo de palco, microfone, slide com monte de imagem e palestrante em sala separada, não funciona. Ainda dentro desse item, rápidas exposições, mais conversas, e ambiente bem descontraído parece ser a melhor escolha</li>
</ul>


<p> Por fim, é que existem pessoas que querem coisas do genero e arrisco dizer que pagariam por isso.  Logo, por que não fazer?</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/04/quando-fazer-refactoring/">Quando Fazer Refactoring</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-04T16:59:00-02:00" pubdate data-updated="true">Feb 4<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/02/04/quando-fazer-refactoring/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2014/02/04/quando-fazer-refactoring/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>TL; DR;
Sempre que falo sobre refactoring, sempre ouço a pergunta de quando fazer e como alocar tempo para realizá-lo.</p>

<p>Para mim não existe um quando e nem quantidade de tempo para refactoring: sempre é momento de fazê-lo. Se simplesmente o refactoring não for considerado, mesmo que tenha a melhor estrutura e arquitetura, seu sistema irá ficar obsoleto e se tornará um grande legado. Fazer refactoring é um dos pilares para mantermos a qualidade da base de código.</p>

<h2>REFACTORING</h2>

<p><a href="http://martinfowler.com/">Martin Fowler</a> em seu livro <a href="http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672">Refactoring</a>, define como sendo a prática de melhorar o código em busca de maior clareza, melhor estrutura para extensão, maior comunicação, etc &hellip; sem alterar o comportamento.</p>

<p>Refactoring é a técnica para manter o seu código atual, sem duplcidades (DRY), seguindo boas práticas e princípios como o <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design">SOLID</a>).</p>

<p>Uma boa analogia é de sempre buscarmos a melhor forma de resolver o mesmo problema, tendo em vista a clareza, a boa comunicação, facilidade de extensão. Note aqui que não falei de perfomance.</p>

<h2>PORQUE REFACTORING</h2>

<p><a href="http://pt.wikipedia.org/wiki/Kent_Beck">Kent Back</a>, possui uma citação interessante que explica bem o porque:</p>

<p><em>Programs have two kinds of value: what they can do for you today and what they can do for you tomorrow. Most times when we are programming, we are focused on what we want the program to do today. Whether we are fixing a bug or adding a feature, we are making today&rsquo;s program more valuable by making it more capable.
You can&rsquo;t program long without realizing that what the system does today is only a part of the story. If you can get today&rsquo;s work done today, but you do it in such a way that you can&rsquo;t possibly get tomorrow&rsquo;s work done tomorrow, then you lose. Notice, though, that you know what you need to do today, but you&rsquo;re not quite sure about tomorrow. Maybe you&rsquo;ll do this, maybe that, maybe something you haven&rsquo;t imagined yet.
I know enough to do today&rsquo;s work. I don&rsquo;t know enough to do tomorrow&rsquo;s. But if I only work for today, I won&rsquo;t be able to work tomorrow at all.
Refactoring is one way out of the bind. When you find that yesterday&rsquo;s decision doesn&rsquo;t make sense today, you change the decision. Now you can do today&rsquo;s work. Tomorrow, some of your understanding as of today will seem naive, so you&rsquo;ll change that, too.
What is it that makes programs hard to work with? Four things I can think of as I am typing this are as follows:</em></p>

<p><em>1. Programs that are hard to read are hard to modify.</em></p>

<p><em>2. Programs that have duplicated logic are hard to modify.</em></p>

<p><em>3. Programs that require additional behavior that requires you to change running code are hard to modify.</em></p>

<p><em>4. Programs with complex conditional logic are hard to modify.</em></p>

<p><em>So, we want programs that are easy to read, that have all logic specified in one and only one place, that do not allow changes to endanger existing behavior, and that allow conditional logic to be expressed as simply as possible.</em>
<em>Refactoring is the process of taking a running program and adding to its value, not by changing its behavior but by giving it more of these qualities that enable us to continue developing at speed.</em></p>

<p>Transcrevendo, seria dizer que todos os sistemas possuem 2 valores: o que pode ser feito hoje e que pode ser feito amanhã.  Na maioria dos casos, sempre pensamos no presente. Porém, sistemas evoluem e novas funcionalidades, correções de bugs, vão ocorrendo e o código sendo alterado.  Nesses ciclos, acabamos duplicando código, adicionando responsabilidades a métodos, alterando as lógicas, etc. Com isso o código vai ficando confuso e complexo.</p>

<p>A técnica de Refactoring, é justamente olhar para esse sistema e buscar sempre um jeito melhor te atender os requisitos. Jeito esse que leva em conta coisas como comunicação, clareza, facilidade de extensão, e coisas simmilares.</p>

<p>Por isso, se quisermos manter um sistema com uma boa qualidade e simples de ser entendido e extendido, é muito importante sempre realizarmos refactorings.</p>

<h2>REFACTORING, TESTES AUTOMATIZADOS e TDD</h2>

<p>Não é meu objetivo entrar muito a fundo no assunto, entretanto, é importante dizer que é muito díficil fazer Refactoring em sistemas sem testes automatizados. Não é impossível. Mas extremamente difícil. Isso porque, ao final de um ciclo, você terá que testar se nenhum comportamento esperado foi alterado.</p>

<p>Por isso, de forma a simplificar, não fazemos refactoring sem testes. Caso o seu sistema não tenha testes, primeiro, faça o teste. Depois faça o Refactoring. Nisso podemos encaixar o TDD. O próprio trabalho de escrever os testes te ajudará a decidir o que mudar, a melhor forma, etc.</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/14/reinstalando-vim-com-python/">Reinstalando O Vim Na Sua Máquina Com Suporte a Python E Ruby</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-14T17:44:00-03:00" pubdate data-updated="true">Oct 14<span>th</span>, 2013</time>
        
           | <a href="/blog/2013/10/14/reinstalando-vim-com-python/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2013/10/14/reinstalando-vim-com-python/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Esse é um post para ajudar a me lembrar de uma procedimento e quem sabe ajudar alguém com o mesmo problema.</p>

<p>Eu uso como editor padrão o VIM (algumas vezes o MACVim). Além disso uso muito Python e Ruby como linguagens para desenvolver meus projetos. Para facilitar esse meu dia a dia, uso alguns plugins que me ajudam como por exemplo o python-mode e o jedi. O python-mode ajuda com as validações de pep8, pyflakes, etc. Já o jedi ajuda nos imports do python. Para ruby eu tenho o sintaxe highlight mesmo.</p>

<p>Tudo isso funciona perfeitamente no meu MACVim, porém no vim não estava funcionando. Ambos tinham sido instalados via homebrew. Buscando pelo Google, achei que a solução era compilar o vim manualmente. Isso realmente resolveu meu problema, e segue abaixo os passos que fiz. Primeiro certifique-se  tem instalado o mercury no seu computador (hg).</p>

<p>hg clone <a href="https://vim.googlecode.com/hg/">https://vim.googlecode.com/hg/</a> vim_source
cd vim_source
./configure &mdash;disable-nls &mdash;enable-multibyte &mdash;with-tlib=ncurses &mdash;enable-pythoninterp &mdash;enable-rubyinterp &mdash;with-features=huge
make -j 3 &amp;&amp; sudo make install</p>

<p>Com isso o sistema irá reinstalar todo o vim com os suportes e links corretos.</p>

<p>Espero que ajuda alguém.</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/28/code-review/">Code Review</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-28T20:48:00-03:00" pubdate data-updated="true">Sep 28<span>th</span>, 2013</time>
        
           | <a href="/blog/2013/09/28/code-review/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2013/09/28/code-review/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>TL; DR;</p>

<p>Embora toda experiência, conhecimento de processos e boas práticas, ninguém está imune a cometer erros, escrever código com BUG e/ou ruim. Todo ser humano é imperfeito e está fadado a cometer erros mesmo que sendo um gênio e tendo um profundo conhecimento. BUGS e códigos mal escritos não são somente fruto de desconhecimento e despreparo mas também, de condições e contextos no qual o desenvolvedor está inserido. Sendo assim, a questão não está em não cometer o erro (bugs, código mal <em>escrito</em>, etc) e sim procurar formas de detectá-lo o mas breve possível evitando assim que esse tenha um ciclo de vida longo.</p>

<h2>O problema do código <em>feio</em></h2>

<p><em>&ldquo;Escrever código para máquina é fácil.&rdquo;</em></p>

<p>Nem sempre os problemas de um sistema estão em BUGs ou aderência aos requisitos. Muitas vezes, para não dizer a maioria, os maiores problema estão em códigos mal escritos, difícies de manter, duplicados, sem padrão, etc. Isso se agrava quando falamos em projetos onde temos mais  de uma pessoa envolvida e com  mudanças na equipes (entrada de pessoas novas por exemplo). Logo, é preciso buscar formas para que esse tipo de coisas não aconteça.</p>

<p>Escrever código também é uma forma de comunicação e é necessário dar a essa prática a mesma atenção de um texto. Embora, códigos sejam instruções para computadores realizar, é preciso pensar em quem irá ler esse código e ter em mente que essa pessoa tem que ser capaz de entender corretamente a mensagem e propósito da arquitetura e forma deste sitema. Outros além dos autores iniciais, muito provávelmente, irão dar manutenção, e com isso precisarão entender bem como as peças se encaixam para resolver o domínio.</p>

<p>Falhar em escrever um código legível, compreensível, com padrões perceptivos, é escrever código legado e fadado a morte.</p>

<p>Código bem feito leva a todos futuros autores a seguir um padrão e a entender sem grandes esforços como as relações se desenrolam. No oposto, código mal escrito, o efeito é inverso: têm-se um empilhamento de funcionalidades, duplicações, diversos padrões, formas, código <em>obscuro</em>, etc.</p>

<h2>Estudos e estudiosos do assunto</h2>

<p>Tendo como ponto de partida o fato de que código é uma forma de comunicação semelhante as demais e que é preciso buscar a excelência nisso, muitos estudiosos do assunto buscam formas, processos, ferramentas, para evitar que se produza código ruins (mal escritos). Linguagens como Python, Java, etc criam convensões de boas práticas, <em>code styles</em> (estilo de escrita de software). IDE&rsquo;s criam validadores de sintaxe. Estudiosos de processo, procuram por práticas para ajudar o desenvolver a não escrever ou achar os defeitos o mais breve possível.</p>

<p>Existe um artigo interessante no site de developer da IBM que lista as 11 praticas provadas que realmente ajudam na revisão de código <a href="http://www.ibm.com/developerworks/rational/library/11-proven-practices-for-peer-review/">Leia o artigo</a>.</p>

<p>A revisão de código é uma das práticas, juntamente com o <em>Pair Programming</em> (programação em pares) que vêem de encontro a resolver o problema de código <em>ruim</em>. A programação em par é a prática onde duas pessoas trabalham juntas na concepção e escrita da funcionalidade. Ela resolve em parte o problema pois são dois pares de olhos vendo. Porém, ainda é possível escrever coisas que não sejam <em>&ldquo;legíveis&rdquo;</em> a futuros programadores daquele sistema.</p>

<p>A revisão de código tem sido mais eficiente nesse sentido. Revisar um código não consiste apenas em outras pessoas lerem o código escrito antes de alguma determinada etapa. Consiste no uso de ferramentas e analisadores também. Inclusive uma boa prática é se algo pode ser analisado pelo computador é melhor que ele que faça e não outro, como por exemplo, complexidade ciclomática, code styles, duplicação, etc.</p>

<h2>Como resolver, como fazer para implementar essa prática</h2>

<p>Uma vez que se tenha optador pela revisão de código, o primeiro passo consiste em simplesmente fazer. Começar da forma que o time desejar. Os ajustes, como toda boa prática, vem com  tempo, e na medida da maturidade e domínio do processo, vai se mudando e adaptando.</p>

<p>. Como já foi abordado acima, devem buscar ferramentas para analisar a base de código nos mais diversos aspectos. Linguagens como python tem analisadores de pep8(conjunto de boas práticas de escrita de código), analisadores estáticos (analisam variaveis, duplicidade, e outra coisas); já Java tem IDE&rsquo;s que vem com suite grande de ferramentas nesse mesmo sentido. Já em Ruby e Javascript tais coisas são trabalhos em andamento.que vem com suite grande de ferramentas nesse mesmo sentido. Já em Ruby e Javascript tais coisas são trabalhos em andamento.</p>

<p>. todos tem seu código revisto.  Não é só responsabilidade os engenheiros senior revisar. É de todos.</p>

<p>. Uma boa forma é que o código só seja enviado para o repositório (git, svn, etc) se foi revisado. Por isso, o desenvolvedor antes de <em>comitar</em>  ou dar <em>push</em> chama outra pessoa e faz.</p>

<p>. Projetos com times grandes podem trabalhar, caso seja usem coisas semelhantes a git, usar patches. Assim, cada um tem seu &ldquo;repositorio&rdquo; e na hora de integrar criam e enviam um patch. Esse patch irá ser revisto por algum outro membro.</p>

<p>. Evite fazer com muito código. O ideal, segundo o  artigo citado, é não passar de 200 a 400 linhas de código. Isso reforçar o conceito de fazer pequenos passos e ir enviando para o repositorio.</p>

<p>. Evite o efeito Big Brother&hellip; Faça reviews abertos e de forma clara. Deixe tudo muito aberto e simples.</p>

<p>. Torne a prática uma cultura do time e não mais um processo a seguir. A revisão de código deve ser desejada por todos e seguida. Pedida.</p>

<h2>Concluindo</h2>

<p>Independente da forma e de como irá realizar, é importante entender que código deve ser legível. Código deve ser compreensível a outros humanos também, não somente a máquina. Isso irá aumentar a vida do sistema, facilitar novos colaboradores (para os casos de open source), etc.</p>

<p>Code Review é uma boa forma de garantir isso.</p>

<h2>Leia mais</h2>

<p><a href="http://alexgaynor.net/2013/sep/26/effective-code-review/">Effective Code Review &ndash; Alex  Gaynor</a></p>

<p><a href="http://agile.dzone.com/articles/what-makes-peer-code-review-agile">What Makes Peer Code Review an Agile Process? &ndash; Lyndsey Clevessy</a></p>

<p><a href="http://www.cio.com/article/472372/Running_an_Effective_Code_Review">Running an Effective Code Review &ndash; Esther Schindler</a></p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/22/criando-wdigets-javascript/">Criando Widgets Javascript</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-22T10:35:00-03:00" pubdate data-updated="true">Sep 22<span>nd</span>, 2013</time>
        
           | <a href="/blog/2013/09/22/criando-wdigets-javascript/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2013/09/22/criando-wdigets-javascript/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>TL;DR;</p>

<p>Nos projetos atuais  nos quais trabalho, muitas vezes acabamos fazendo o que chamados de Widget. Esses widget são feitos para serem &ldquo;inseridos&rdquo; e usados outros portais e produtos. Na maioria dos casos, esses widgets são como apps escritas em javascript para consumir uma api e montar um dado dentro da página onde ele foi inserido.</p>

<p>O <a href="http://leobalter.net">Leonardo Balter</a> numa <a href="http://www.slideshare.net/leobalter/guia-de-sobrevivncia-js-no-mundo-open-source">palestra</a> que ele deu no Front in Rio 2012, abordou bem o assunto sobre como podemos escrever frontend apps sem inteferir no contexto da página onde está posta. Por isso pretendo apenas extender o conceito.</p>

<h2>Contextualizando</h2>

<p>Vamos lá, a grande maioria das pessoas, atualmente, que dizem conhecer e saber programar, apps front, faz uso de alguma biblioteca. Sem grandes pesquisas, creio que a maioria delas deva usar algo como JQuery, Mootools, BackBoneJs, AngularJS, ou similares.</p>

<p>Tais libs são &ldquo;uma mão na roda&rdquo; e realmente facilitam a codificar, testar, etc.</p>

<p>A pergunta que faço é:  Precisamos de todos os recursos disponíveis nesses frameworks/bibliotecas? Acredito que na maioria dos casos, se escrevessemos somente em Javascript puro, usando HTML e CSS, e não mais do que isso, conseguiríamos entregar o desejado.</p>

<h2>Entendendo o &ldquo;Problema&rdquo;</h2>

<p>Ao analisar mais detalhadamente a situação, conversando com alguns colegas especialistas em front end e com outros nem tão especialista assim. Uma das coisas que notei é que muito deles não conhecia de fato Javascript: Sabiam detalhes de cada elemento HTML, funções e motivos de cada linha de CSS; entretando desconheciam recursos básicos da linguagem Javascript, como por exemplo, fazer um laço de <em>for</em> (muito usavam a, por exemplo, a função each do jquery).</p>

<p>Com isso, é possível concluir uma exagerada dependência de bibliotecas, para fazer coisas que são perfeitamente possíveis de serem feitas sem elas, usando apenas JS puro. O resultado disso, são widgets com megas de tamanho, sendo que a lógica deles mesmo são meros  kilobytes, o restante são as bibliotecas que eles carregam junto (Jquery tem minificado 93kb, veja o site). Isso pode parecer um detalhe banal num mundo onde  casas tem links de Mb&hellip; Porém uma nova variável se apresentou no horizonte que é o mundo do mobile.</p>

<p> Outro ponto interessante foi uma pesquisa recente (não consegui achar o link) onde afirma que, sites que são lentos para carregar tem menor taxa de conversão. Isso mesmo, tempo é dinheiro, literalmente. Se o seu site leva mais de  5 segundos  para mostrar algo, já se foram quase 50% das pessoas aí (CHUTE!!!!).</p>

<p>Voltando para o mobile, ter sites grandes e pesados de carregar significa mais gasto de 3g e bateria. Maximiliano Firtman, fez numa edição do BrazilJS, uma ótima apresentação sobre o assunto, onde mostar números, dados mais concretos que meus chutes. E as pessoas tem pouca paciência &ndash; menos ainda no mobile, pode cre &ndash; para esperar seu site gigante carregar todas as libs e processá-las.</p>

<p>Mais aí você pode dizer, que usa a técnica de deixar o  carregamento no final de página. Desculpa meu amigo, mas o seu site ainda é pesado de carregar, vai consumir bando e bateria no mobile e pode gerar alguma perda na entrega de conteúdo.</p>

<p>Ok. Dito isso, voltemos paras os widgets.</p>

<p>Se você está criando uma widget e esse tem dependências de centenas de kb de libs (template lib, dom lib, ajax lib, etc) você se encaixa na mesma análise. E pior. Você está fazendo isso com qualquer um que use seu  código &ndash; as vezes sem saber da  âncora que você é no site deles.</p>

<p>Outro aspecto de widget gordos (vou chamá-los assim para facilitar), é que eles também podem gerar conflitos com outras coisa na páginas dos outros: imagine a questão das versões como podem gerar um verdadeiro inferno.</p>

<h2>Os conflitos</h2>

<p>Para seguir adiante com a discussão é importante que fique claro que menos é mais: ou seja, quão menor for sua app/widget, melhor. Não se iluda, isso dá trabalho. Abrir mão de libs, significa você cuidar de vários detalhes antes abstraídos, porém, posso garantir que o resultado compensa.</p>

<p>Gosto sempre de usar exemplos. Acredito que eles sejam a melhor forma de mostrar um ponto de vista.  No meu trabalho fizemos um widget. Esse widget vai em quase todos os produtos e portais e portanto é bem usado.  Esse widget, no momento que foi feito, fizeram a escolha de implementá-lo usando libs. Pois bem.</p>

<p>Até aí foi uma escolha simples e até bem intencionada. Com o uso de libs e seus recursos muita complexidade seria resolvida e os desenvolvedores ganhariam tempo para lidar com os desafios do produto e não dos navegadores, etc.</p>

<p>O problema é que com isso, prendemos nossa solução a uma lib e sua versão. Obrigamos os produtos que queriam usar esse widget e ter essa versão, essa lib.</p>

<p>Os mais experientes já devem estar imaginando o cenário que isso nos levou&hellip; Hoje temos diversos produtos usando a implementação e reclamando do tamanho, do fato de termos uma versão muito antiga, conflito com implementações.</p>

<p>Nesse caso em específico, além do uso de libs, houve um sério problema de engenharia de software. Poderíamos ter componentizado melhor, separado melhor e essa mudança para versão mais nova seria mais simples.  Entretanto, nos amarramos demais a biblioteca e agora teremos que reescrever tudo.</p>

<p>Para coroar nossa análise, se tivessemos usado simples JS puro &ndash; isso daria trabalho mais é totalmente possível &ndash; agora teríamos um produto bem mais fácil de evoluir e não atrapalharíamos a vida de nossos clientes/usuários.</p>

<p>No mesmo tempo que essa app foi feita, uma outra app foi feita por outro time. Também é usada por todos os portais. A diferença é que eles optaram por fazer com VanillaJS. Deu muito trabalho, problemas de cross-browser para resolver, ajax, etc. Mas no final eles conseguiram e tem sido um benchmark para nós todos. Eles provaram que a entrega foi bem melhor  e  com usuários felizes.</p>

<h2>A conclusão</h2>

<p>Vamos lá a formula de bolo para ajudar a:</p>

<ol>
<li>Tentar sempre usar somente javascript. Mais nada</li>
<li>Lembre  de isolar bem o seu contexto de váriaveis.</li>
<li>Sempre que possível use de namespaces/</li>
<li>Se não der para usar só js, procure por um micro framework para resolver o seu problema de forma bem específica. Embede o código dessa lib na sua.</li>
<li>Menos código, menos bugs.</li>
<li>Seja cuidadoso e sempre se coloque no lugar da pessoar que irá usar.</li>
</ol>


<p><em>&ldquo;Escreva como se a pessoa que fosse usar  seja um psicopata e sabe onde mora&rdquo;</em></p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/06/voce-nao-e-o-twitter/">VOCÊ NÃO É O TWITTER</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-04-06T13:27:00-03:00" pubdate data-updated="true">Apr 6<span>th</span>, 2013</time>
        
           | <a href="/blog/2013/04/06/voce-nao-e-o-twitter/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2013/04/06/voce-nao-e-o-twitter/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>TL;DR</em></p>

<p>Surgiram atualmente diversos artigos onde grandes e famosos produtos (e players da internet) explicam como o time de engenharia mudou a tecnologia/ linguagens e conseguiu maravilhas em redução de máquina e aumento de carga em seus sistemas.</p>

<p>A grande maioria dos que li, usavam Ruby on Rails e passaram a usar Java (inclua aqui Scala, Groovy, Clojure) ou Go ou até Python em seu lugar, e com isso, reduziram drásticamente o custo de infra (energia, máquinas, resfriamente, etc) e/ou aumentaram sua capacidade carga (quantidade de requisições, conexões, etc). Enfim, foram além da simples troca de arquitetura.</p>

<p>Entretanto, antes que todos comecem a demonizar Ruby e/ou as ditas linguagens modernas é preciso analisar o contexto desses artigos e entender que nem de longe somos um <a href="http://twitter.com">Twitter</a> para nos preocuparmos com esse tipo de coisa agora.</p>

<h2>Um pouco sobre mim e porque posso falar sobre o assunto</h2>

<p>Tenho em torno de 12 anos de profissão. Hoje, sou desenvolvedor senior da <a href="http://www.globo.com">Globo.com</a>, atuando no time de jornalismo &ndash; responsável por sites como G1, Ego, Cobertura de Eventos, etc.</p>

<p>A <a href="http://www.globo.com">Globo.com</a> é uma empresa onde se desenvolve os maiores portais de jornalismos, esportes e entretenimento do Brasil . Fora isso, temos plataformas de vídeos, imagens, música, em milhares de outras coisa.</p>

<p>Uma das coisas legais de se trabalhar lá é o fato de sempre procurarmos a melhor ferramenta para o trabalho. E com isso, sempre estamos experimentando  as tecnologias, linguagens, plataformas, e tudo mais que nos permite sermos mais produtivos e eficientes.</p>

<p>Atualmente a grande maioria dos produtos que desenvolvemos são feitos usando Python e Ruby (e seus frameworks como Tornado, Django, Ruby on Rails, Sinatra, etc).</p>

<p>Nossos produtos tem acessos bem grandes: Portais com milhões de vísitas únicas por dia; streaming de vídeos na faixa de gigabytes por dia, terabytes de arquivos (imagens, html, css, javascripts) e por aí vai.</p>

<h2>Diferenciando um pouco &hellip;</h2>

<p>Diante do relato acima muitos poderiam pensar que <a href="http://www.globo.com">Globo.com</a>, deva ter as mesmas preocupações que um Facebook, <a href="http://twitter.com">Twitter</a> ou <a href="http://soundcloud.com">SoundCloud</a>.</p>

<p>Posso adiantar que, sobre determinados aspectos, sim: Nenhum de nossas aplicações e novas funcionalidades vão para &ldquo;produção&rdquo; (para uso do nossos usúarios) sem que antes façamos bons testes de carga, testes de segurança, entre outras coisas relacionadas. Ainda na fase de desenvolvimento, temos a preocupação de fazermos coisa que deverão aguentar milhões de acessos, milhares de conexões simultaneas, picos, etc, sem jamais deixar de atender uma requisição.</p>

<p>Porém se compararmos nosso volume de acesso e nosso tipo de produto, não somos parecidos com o pessoal do <a href="http://twitter.com">Twitter</a>, <a href="http://www.google..com">Google</a>, <a href="http://soundcloud.com">SoundCloud</a>, entre outros.</p>

<p>Nossos produtos são em sua maioria estáticos: Um vez que são produzidos, nos geramos uma cópia estática e a servimos para os clientes. O <a href="http://twitter.com">Twitter</a>, por exemplo, tem um natureza muito mais dinâmica: o conteúdo é servido por usuário (com toda certeza deve existir um cache no meio do caminho) a cada requisição.</p>

<h2>Entendendo o problema e o contexto</h2>

<p>Quando pensamos em <a href="http://www.google..com">Google</a>, <a href="http://soundcloud.com">SoundCloud</a>, logo pensamos em um datacenter gigantesco com milhares de máquinas. Tudo isso para atender a grande demanda de processamento que é gerada pelas milhões de requisições que os usuários fazem. São buscas, buscas por músicas, cadastros de novos usuários, posts, documentos, edição, envio de novo conteúdo, etc.</p>

<p>Para esse tipo de acesso, um pouco que se possa ganhar em desempenho, seja por uma escolha de arquitetura, seja pela troca de linguagem é algo muito significativo.</p>

<p><em>Lembre-se que estamos falando de parques com milhares máquinas.</em></p>

<p>Isso porque se conseguirmos, num cenários desses, reduzir em 10% a quantidade de máquinas e processamento, imaginem o quanto de dinheiro que isso representa na conta no final do mês. Muito né.</p>

<p>Por isso que empresas e aplicativos desse porte, precisam, constantemente, buscar por meios de reduzir processamento e atender mais requisições. Por que empresas como essas correm atrás de tecnologias, arquitetura, linguagens, etc que possam ajudá-las nessa missão, nem que sejam em 1%.</p>

<h2>Onde eu entro nisso tudo? Porque eu não sou o twitter?</h2>

<p>A grande maioria das pessoas, hoje em dia, está desenvolvendo sistemas que mal atenderão um milhar de pessoas. Existe uma infinidade de pessoas estão trabalhar em projetos de aplicações internas a empresas, os ditos corporativos.</p>

<p>Pouquíssimos são aqueles que estão desenvolvendo algo para uma quantidade superior a centenas de milhares. Nem vou falar naqueles que estão desenvolvendo para milhões.</p>

<p>Enfim, a grande maioria, está criando produtos para no máximo milhares de acessos.</p>

<p>Alguns podem dizer: eu tenho a minha startup e estou desenvolvendo um produto . E quero muito que ele atinja milhões de usuários como um <a href="http://facebook.com">Facebook</a>. Entretando, novamente, a grande maioria em seu lançamento contará com centenas de acesso e terá um crescimento bem linear e vegetativo.</p>

<p>Mesmo que ocorra um <em>boom</em> no acesso, isso é bem pouco provável, não é preciso pensar nisso quando nem o produto existe ainda.</p>

<p>O que quero dizer é que antes que comecemos a fazer a guerra de dizer que agora todos nós devemos largar o Ruby on Rails, ou Django, ou PHP, etc e partir para desenvolver em Assembly, precisamos entender que isso ainda não é o nosso problema.</p>

<p>Nosso problema é ainda entregar valor para o cliente o mais rápido possível. Para grande maioria de nossas aplicações o custo de infra é infimo &ndash; quase desprezível &ndash; frente ao custo de desenvolvimento. Por isso usar de tecnologias de nos dê produtividade ainda é a melhor escolha.</p>

<p>Fazendo referência ao título do POST, não somos o <a href="http://twitter.com">Twitter</a>, e por isso não devemos ainda nos perder nessas dicussões.</p>

<h2>Um grande porém &hellip;</h2>

<p>Porém, mesmo que a gente não esteja na equipe de desenvolvimento da <em>engine de busca do Google</em>, precisamos estar <em>antenados</em> com que acontece a nosso redor. É legal saber que mudanças de arquitetura e tecnologia podem ter um impacto em nosso produtos.</p>

<p>Mais importante é saber das opções existente e a experiência de <em>missão crítica</em> desses grandes players e quem sabe, quando precisarmos, seguir por um caminho menos obscuro.</p>

<p>Hoje na <a href="http://www.globo.com">Globo.com</a> já estamos discutindo usar outras coisa além de Python e Ruby. Não descatarmos por completo JVM e estamos já criando coisas com <a href="http://golang.org">Go</a>.</p>

<p>Esse era o recado que gostaria de deixar para vocês.</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/21/sitemas-com-responsabilidade-unica/">Sistemas Com Responsabilidades únicas</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-21T21:09:00-03:00" pubdate data-updated="true">Mar 21<span>st</span>, 2013</time>
        
           | <a href="/blog/2013/03/21/sitemas-com-responsabilidade-unica/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2013/03/21/sitemas-com-responsabilidade-unica/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Introdução</h2>

<p>Muitos desenvolvedores já estão familiarizados com diversos princípios de engenharia de software, como por exemplo alguns enunciados pelo livro <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code </a>. Tais princípios ficaram eternizados com a sigla SOLID, que é acronimo e significa:</p>

<p> <em>S</em>ingle Responsability Principle ( Principio de Responsabilidade Única);</p>

<p> <em>O</em>pen Close Principle ( Principio do aberto para extensão e fechado para modificação);</p>

<p> <em>L</em>iskov  Substitution Principle (A classe filha pode ser substituida pela classe pai);</p>

<p> <em>I</em>nterface Segregation Principle (expor interfaces não objetos);</p>

<p> <em>D</em>ependency Inversion  Principle ( Dependencias baseadas na abstração e não nas implementações concretas )</p>

<p>Para saber um pouco mais, siga clicando <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">aqui</a>*</p>

<p>Aplicando essa definições em nossos código, a idéia é ter um código mais limpo: código legível; fácil de compreender por outros desenvolvedores; simples de evoluir; simples de manutenciar; etc. A questão é que, mesmo usando toda essa engenharia, todos nossos sistemas atuais tendem a crescer e ganhar complexidade.</p>

<p>Todos os sistemas nascem simples: com responsabilidades únicas e bem definidas. Assim após a nossa primeira <em>release</em>, nosso sistemas evolui, ganhando novas funcionalidades, acertos, melhorias , ajustes para melhorar perfomance, refactorings, etc. Com o passar do tempo, nosso pequena e bem escrito aplicativo, torna-se um megazord de complexidade, duplicidade de código, e outras coisas que nenhum de nós gosta. Enfim, ele se torna um grande legado que ninguém quer mais mexer.</p>

<p>Tenho certeza que todos tem algum projeto que trabalhou que serve de exemplo para a situação descrita acima.  Lembra daquele sistema que tinha, lá no início, algumas centenas de linha de código apenas e já de milhares (até milhões); ou/e daquele projeto super bem arquitetado e hoje é uma bagunça sem fim que até mesmo que trabalhou desde início se perde para entender como as chamadas <em>trafegam</em> para completar uma requisição.</p>

<p>Mesmo que esse ditos projetos estejam usando testes automatizados e tenha sidos feitos seguindo princípios como TDD. Mesmo que eles sofram refactorings constantes, o fato é que eles crescem e vão adquirindo novas responsabilidades antes não previstas. Com isso, vamos torcendo aquele modelo original e amontando código.</p>

<p>Diante disso, o que vejo e vivencio é que a medida que essas bases de código crescem, fica impossível de manter principios de reutilização, <em>DRY</em>, padrões de nomes, <em>code style</em>, e diversas outras coisas importantes. Enfm, acabamos um imenso legado que é caro demais de evoluir, muito caro de reescrever e muito importante para nosso cliente que não abra mão dele e tem novas necessidades a serem atendidas.</p>

<h2>Nosso dilema atual</h2>

<p>Como disse, os sistemas crescem. E com eles suas bases de código.</p>

<p>Poderíamos dizer que este problema já é conhecido e muito bem abordado pelo Michael Feathers em seu <a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">livro</a> sobre código legado: podemos sim isolar e aplicar todas as técnicas sugeridas, mas bases de código grandes, são bases de código grandes e ponto final. Pdemos melhorar os métodos, encapsular melhor algumas, etc &hellip; a questão que ainda temos um modelo que não foi feito para aqueles novos casos, ainda temos situações novas que não estavam previstas e poucas possibilidades de interface do nosso sistema.</p>

<p>Se não existessem os problemas financeiros ou quaisquer outras <em>constraints</em> tenho certeza que a maioria dos desenvolvedores, diriam que está na hora de reescrever todo o sistema.  Todos nós adoramos projetos <em>Green Field</em> (projetos que estão começando do zero).</p>

<p>Em novos projetos, temos as oportunidade de desenhar bem a nossa arquitetura, aplicar novos conceitos e utilizar novas tecnologias.</p>

<p>A questão é que fazer isso com sistemas de milhares de linhas de código é uma tarefa árdua e que custa bastante caro &ndash; nenhum gerente, cliente, PO&hellip; vai querer pagar por isso &ndash; até porque você não estará entregando nenhum valor novo (estará sim se pensarmos em infra, mais request, e outras coisas parecidas, mas poucos clientes percebem isso logo de cara)</p>

<h2>Motivos para reescrever sistemas</h2>

<ol>
<li><strong>Tecnologias caducam, envelhecem:</strong></li>
</ol>


<p>Muitas tecnologias se tornam ao longo do tempo obsoletas e ultrapassadas. Sempre temos uma nova versão da linguagem, um novo servidor, um banco de dados mais moderno ou que utilize um outro paradigma que resolve melhor o seu problema&hellip; enfim a tecnologia evolui e traz novas soluções &ndash; e melhores &ndash; para os nosso problemas.</p>

<ol>
<li><strong>Nós aprendemos:</strong></li>
</ol>


<p>Com o passar do tempo e com a experiência vemos que, nem sempre o caminho que adotamos foi o melhor. Também vemos que existem jeitos melhores de implementar determinada lógica.</p>

<p>Existe o fato também, que evoluímos como profissionais: com isso vemos que aquele sistema que fizemos a um tempo atrás, poderia ter sido feito de um jeito diferente. Infelizmente mudanças desse tipo não dá para fazer de forma gradual. Geralmente, eles são mudanças radicais e temos que fazer tudo de uma vez só.</p>

<ol>
<li><strong>todo sistema tem prazo de validade:</strong></li>
</ol>


<p>Um outro bom motivo para reescrevermos nosso sistema é ligado ao negócio. Muitas vezes vemos que a forma de nosso negócio mudou e que o sistema atual com sua base de código infinita não nos atende mais. Mesmo que façamos diversos apendices, o sistema não é mais capaz de nos atender com proficiencia. Se tornam aqueles sistemas cheios de jeitinhos para fazer coisas. O usuário tem que fazer um cursinho para saber todos os &ldquo;pulos do gato&rdquo; para ele conseguir concretizar uma operação. Sistemas ERPs são os melhores exemplos disso. Você acaba torcendo o seu problema para caber dentro daquele sistema que é impossível de mudar ou reescrever.</p>

<h2>Vamos ao que interessa</h2>

<p>Fica um bom tempo falando sobre a questão de engenharia de software e do problema de sistemas com muitas linhas de código. Falei também dos motivos que podemo nos levar a querer reescrever um sitemas. Mas para que?</p>

<p>Escrevi sobre tudo isso para mostrar que precisamos dar o passo seguinte no desenvolvimentos de software. Precisamos pensar em sistemas como peças únicas de um conjunto para resolver problemas. Sendo assim, essas unidade deve ser responsavel por resolver um e somente um aspecto do problema e não todo ele. A solução se dá pela soma das partes que agindo em conjunto atendem ao nosso domínio.</p>

<p>Precisamos aplicar os conceitos de SRP (veja acima) na concepção de nosso sistemas. Ao invés de fazermos uma peça única e monolítica que aborde todo o nosso dominio, fazmemos pequenas partes que cuidam de cada aspecto.</p>

<p>Ganhamos com isso sistemas pequenos, e simples de manter.  Num caso que li recentemente, cada peça ficou com poucas centenas de linhas. Isso facilita manter pois bases pequenas são mais simples. Bases pequenas são mais fácil de entender e manter seu padrões; bases pequenas são mais fácil de jogar fora e fazer de novo. No mesmo case que citei acima, eles reescrevem uma parte em uma semana e foi imperceptível para o cliente.</p>

<p>Outro aspecto é que se fizermos com pequenas partes e essas partes existirem independentes uma das outras, podemos ir além. Imagine que eu quebre o sistema em diversos serviços que se falem via REST: eu posso literalmente escrever cada serviço numa linguagem diferente que não vai causar nenhum problema. Com isso posso escolher a melhor tecnologia/linguagem para o meu problema. Além disso, mantendo as interfaces, eu posso refazer todo a parte interna sem afetar as outras peças do conjunto.</p>

<p>Isso é simplesmente o céu de todo desenvolvedor.</p>

<p>Em meu trabalho atual estamos caminhando para algo parecido. Ou seja, uma forma mais orientada a serviços, onde cada sistema tem uma responsabilidade e essa é simples. Manter essa coisa simples e com pouca coisa para resolver é a grande chave do sucesso.</p>

<p>Se olhar arquitetura de grandes portais, produtos web (como [Twitter][4], basecamp, <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SoundCloud</a>, etc) verá um monte de pequenos sistemas conversando para atender a demanda do usuário.</p>

<p>Se uma parte se tornar o gargalo, podemos melhorar só aquela parte: colocando mais servidores, reescrevendo, etc.</p>

<p>Isso é aplicavel a qualquer contexto.</p>

<p>A alguns anos atrás trabalhei numa empresa que tinha diversos sistemas que eram integrados através de troca de mensagens (queue e brokers). Claro que nem chega perto do que estou propondo mais foi uma semente e vi que dava muito certo.</p>

<h2>Cenas do próximos capítulos &hellip;</h2>

<p>Mais a frente &ndash; estou terminando de organizar tudo &ndash; pretendo publicar um  novo post explicando melhor como implementar essa questão de sistemas pequenos e com pouco responsabilidade.</p>

<p>Só para deixar curioso, existem formas de fazer sem necessáriamente escrever um monte de sistemas; como existem formas de fazer de forma  bem desacoplada. Enfim fiquem ligados.</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/08/design-pattern/">Design Pattern E Linguagens Dinamicas</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-08T21:16:00-03:00" pubdate data-updated="true">Sep 8<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/09/08/design-pattern/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2012/09/08/design-pattern/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Logo na introdução do livro do GoF, na primeira frase que acredita ser da maior importância para quem deseja ser um desenvolvedor. É ela : <em>&ldquo;Projetar software orientado a objetos é difícil, mas projetar software reutilizável  orientado a objetos é ainda mais complicado&rdquo;</em> .</p>

<p>Fazendo a ponte com um post anterior, escrever código de qualidade, sem saber algo sobre Padrões de Arquitetura (design patterns) é quase impossível. Brinco até que está difícil de estar trabalhando sem saber isso, pois quase toda entrevista o pessoal adora perguntar algo do assunto.  Fora esse aspecto de seleção, saber patterns é uma boa forma de começar a escrever bons sistemas.</p>

<p>Patterns foram uma verdade absoluta, uma lei escrita em pedra até a muito pouco tempo atrás. Ouso dizer que para muitos é quase um axioma onde se um dia for quebrado alterará o equilíbrio da <strong>&ldquo;vida no universo&rdquo;</strong>. Entretanto, com o crescimento do uso de linguagens dinamicas e com paradigmas de classe aberta, parece que a coisa tem mudado um tanto.</p>

<p>Muitos fazem &ldquo;piadas&rdquo; com o livro do Gof (Gang of Four &ndash; Design Patterns, Eirc Gamma, Richard Helm,  Ralph Johson e John Vlissides),  dizendo que na verdade o título de livro deveria ser &ldquo;Como tornar o C++/ Java menos ruim&rdquo;, pois a maioria das soluções apresentadas giram em torno da deficiencias dessas linguagens (Tipagem estática, falta de closures, não ter funções como first class, não terem modelos de open class, etc) .  Sendo, assim, quando temos uma linguagem que não tem essas tais limitações, usar patterns é algo desnecessário.</p>

<p>Concordo em parte com o parágrafo acima. Primeiro é preciso considerar que o livro foi escrito à mais de <strong>14 anos</strong> ( primeira edição saiu em 1996 ou 1997) e pouco se conhecia de linguagens como Python,  Ruby, Groovy, Scala, entre outras semelhantes (embora algumas já existissem).  As duas linguagens que vinham sendo usadas em larga escala eram exatamente o Java e o C++.</p>

<p>Outro aspecto que devemos levar em consideração é que mesmo usando uma linguagem dita moderna, isso não invalida o uso ou conhecimento de padrões de arquitetura. Muito pelo contrário: é importante que conheçamos as motivações por trás de tudo, para que possamos adaptar a nova realidade as soluções catalogadas.</p>

<p>É praticamente impossível pensarmos em escrever uma aplicação, ela ser entregue e jamais ser tocada novamente. Na maioria dos casos ela evoluirá com ou sem o nosso consentimento ou participação. Sendo assim, escrever usando ou baseando-se em padrões facilita em muito o entendimento dos futuros donos deste sistema e além do mais. Quando falamos de equipe, até a comunicação do &ldquo;como deve ser feito&rdquo; fica facilitada: &ldquo;Vamos fazer com um pattern de DTO, por iso temos que fazer os Value Objects, etc&rdquo;.</p>

<h2>Linguagens Dinamicas tem melhores ferramentas:</h2>

<p>Tomando como base Python, Ruby e Groovy, linguagens dinamicas possuem um leque maior de recursos que facilitam em muito criarmos sistemas que evoluam facilmente.  Recursos como closures, open class (classes abertas),  blocos, generadores, decorators, etc, num primeiro momento chegam a negar a necessidade de se criar modelos complexos .</p>

<p>Para que criar um modelo complicado de interfaces, heranças, composições e etc quando podemos simplesmente passar um função como argumento, ou então, capturar e criarmos métodos que ainda nem existem ?</p>

<p>Todos esses recurso facilitam em muito a criarmos sistemas que são simples de evoluir e reutilizar.</p>

<h2>Uma coisa não exclui a outra</h2>

<p>Diante de tudo que foi dito acima, poderia simplesmente, sem muito medo de errar, dizer que Designs Patterns são obsoletos e desnecessários frente a novas ferramentas que possuímos hoje.</p>

<p>Como já disse, concordo em parte com tal afirmação.  Muitas limitações deixam de existir e com isso a necessidade de contorná-las, porém, outros problemas persistem ou tantos outros surgiram.</p>

<p>Padrões não devem ser usados como verdades absolutas e sim como guias para a construção de um sistema bem feito.  Conhêce-los é como uma receita: enquanto estamos aprendendo seguimos-as sem alterar nada, entretanto, a medida que ganhamos experiência sentimos confiante a mudar um pouco e inovar.  Vale ressaltar que não saímos do nada. Não &ldquo;reinventamos a roda&rdquo;. Adaptamos algo que já se provou sucedido a nossa realidade e ferramentas.</p>

<h2>Algumas referências sobre o assunto</h2>

<p><em>Neal Ford</em> tem uma excelente apresentação que fez na Oscon de 2009, onde mostra que algum patterns não fazem mais sentido, porém outros ainda se mostram atuais.  Uncle Bob, em um vídeo e texto em seu blog faz uma afirmação parecida: Diz que design patterns ainda são tão atuais quanto antes e importantes. As bases que compões as soluções ainda são &ldquo;sólidas&rdquo; &ndash; preferir composição a herança.</p>

<p>Convido a quem está lendo a pelo menos conhecer algumas soluções para até mesmo ter do que falar mal. Verá que mudará a forma como pensa a solução.</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/02/qualidade-de-codigo/">Escrevendo Código Limpo</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-02T16:00:00-03:00" pubdate data-updated="true">Sep 2<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/09/02/qualidade-de-codigo/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2012/09/02/qualidade-de-codigo/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Gostaria de começar este artigo com uma frase que está no início do primeiro capítulo do livro <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">CleanCode</a> do <a href="http://en.wikipedia.org/wiki/Robert_Cecil_Martin">UncleBob</a>: <em>&ldquo;You are reading this book for two reasons. First, you are a programmer. Second, you want to be a better programmer. Good, we need better programmers.&rdquo;</em></p>

<p>Vivemos num momento interessante dentro da profissão de desenvolver sistemas: temos as metodologias ágeis, direcionamentos onde o foco é o ser humano (<a href="http://www.amazon.com/Peopleware-Productive-Projects-Second-Edition/dp/0932633439">Peopleware</a>), a busca pela qualidade e pelo desempenho ganham forma e embaseamento, a maturidade nos leva a uma busca constante de excelência, e outras coisas.</p>

<p>Um exemplo disso são os diversos processos e práticas que tem surgido &ndash; e solidificado &ndash;  nos últimos tempos como TDD, BDD, SOLID (veja no livro do <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code </a> &ndash; Robert Martin aka &ldquo;Uncle Bob&rdquo;), etc. Apesar de pessoalmente acreditar que tais iniciativas sejam importantes e determinantes para entregarmos sistemas de qualidade, penso que ainda precisamos de um &ldquo;algo mais&rdquo;.</p>

<p>Escrever &ldquo;código&rdquo;, ao contrário do que muitos pensam, não é uma atividade simples. Segundo Brian Kernigan &ndash; coautor de AWK programing language, <em>&ldquo;é quase o mais complicado dos empreendimentos humanos&rdquo;</em> . Todo sistema nasce simples e consciso. Todo sistema nasce bem feito, porém com o passar do tempo e de seu uso e constantes evoluções sua complexidade aumentam e sua &ldquo;qualidade&rdquo; provavelmente cai. Mesmo que ele tenha 100% de cobertura de testes (coisa que no mundo real é um grande feito) e seu time siga <em>a risca</em> todas as regras.</p>

<h2>TDD e BDD importam</h2>

<p>Antes de mais nada, gostaria de dizer que nada justifica um código sem testes. Testes são uma parte fundamental de um bom código. E eu disse testes. Não disse que fazer TDD ou BDD. Testes garantem um forma simples de manter a aderência as especificações e segurança para realizar futuras mudanças. Autores como Michael Feathers [<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectivily with Legacy Code</a>], chegam afirmar que sem testes não existe a possibilidade da melhora contínua, disciplina essencial para termos bons bases de código.</p>

<p>TDD (<em>Test Driven Development</em>) e BDD(<em>Behave Driven Development</em>) são extrapolações de testes, onde os usamos para nos guiar na busca de uma melhor arquitetura. É possível termos testes automatizados sem seguir tais práticas, porém o contrário não.</p>

<p>TDD e BDD são ótimas ajudantes para termos sistemas robustos e bem feitos, para termos &ldquo;códigos limpos&rdquo;, mas como disse antes, não são o suficiente.</p>

<h2>Design Patterns e princípios como SOLID importam</h2>

<p>Acredito que a maioria das pessoas que leêm meu blog, são pessoas que se preocupam com a qualidade de seus sistemas. Isso deve se refletir em estudos e muita leitura. Sendo assim, creio que a maior parte já tiveram contato &ndash; ou até dominam &ndash; assuntos como padrões de projetos, <em>refactoring</em>, SOLID, etc.</p>

<p>Vou além, e digo que muitos usam tais conhecimentos em seus dias a dias quando estão a trabalhar em seus projetos.</p>

<p>Tais principio são a &ldquo;pedra fundamental&rdquo; sobre o qual o resto todo se apoia. São as tais regras de ouro. Por isso são de extrema importância. Conhecê-las faz um imenso diferencial no código que produzimos pois nos tornamos mais conscientes e preocupados.</p>

<p>Entretanto, somente isso não significa termos um sistema robusto e de qualidade. Já trabalhei em muitos projetos cujos os colegas dominavam e sabiam de &ldquo;coeur&rdquo; cada palavra do Design Pattern, mas produziam código <em>sujos</em> e com pouca qualidade.</p>

<h2>O que é qualidade? Como é um código de qualidade?</h2>

<p>Responder essa pergunta não é algo simples e estou longe de ter as credencias necessárias para me atrever a tamanha responsabilidade. Por isso, recorri aos grandes autores já citados para buscar o que seria a tal qualidade almejada tanto em nossos código.</p>

<p>Em sua grande maioria, os autores que li (Martin Fowler, Kent Beck, Michael Feather, Uncle Bob, Erich Gamma, Joshua Kerievsky, entre outros) concordam em alguns pontos que listo abaixo.</p>

<ul>
<li><p><strong>Código bom é aquele que sobrevive ao seu autor</strong>: código deve ser escrito não para compiladores e sim para pessoas. Código bom é aquele que é fácil de entender e compreender a sua forma. Comunica com clareza a sua função e razão de ser.</p></li>
<li><p><strong>Código tem que ser simples</strong>: a complexidade se dá pela soma das partes. Código simples divide o problema em partes menores e as resolve. E no final chama essas pequenas partes para compor o todo da solução</p></li>
<li><p><strong>Código bom é aquele &ldquo;manutenciavel&rdquo;</strong>: possui toda o ambiente necessário para que ele seja facil de evoluir: testes, documentação, etc.</p></li>
<li><p><strong>Código que vai além da especificação funcional</strong>: um bom código vai além das especificações do cliente. Ele procura cobrir todos os cenários e estar preparado para as situações não previstas; ele é feito por &ldquo;não otimistas&rdquo; (explica mais a frente).</p></li>
</ul>


<h2>Com eu faço de qualidade? Além de TDD (BDD), Patterns, SOLID, o que mais precisa ser feito?</h2>

<p>A resposta é mais simples do que você imagina:</p>

<p><strong>DISCIPLINA</strong></p>

<p>Saber tudo isso não significa e nem faz a mágica de tornar o seu código maravilhoso. Eu falo isso com propriedade. Por muitas vezes sou um feroz defensor de boas práticas e então, meus colegas acham código meu sem teste, mal escrito, com erros de implementação, etc.</p>

<p>Um outro aspecto é a constante verificação da complexidade, qualidade e cobertura de seu código. A disciplina não será nada se não houver um objetivo à atingir.</p>

<p>Outra coisa na qual acredito é que devemos ser menos otimistas ao escrever nossos sistemas. Citando dois amigos &ndash; <a href="http://leobalter.net/">Leonardo Balter</a> e <a href="http://blog.m.artins.net/">Alexandre Martins</a> &ndash; precisamos de trocar o &ldquo;boné de programador&rdquo; e fazer mais <em>&ldquo;Testes de trollagem&rdquo;</em>. Precisamos tentar a todo custo testar os limites do que estamos fazendo. Precisamos ir além da especificação. Michael T. Nygard em seu livro, <a href="http://pragprog.com/book/mnee/release-it">Release It</a>, diz que sistemas que precisam pensar em suas possíveis falhas e serem capazes de suportar os cenários não previstos.</p>

<p>Inclusive, existe um excelente artigo do pessoal da NetFlix, sobre uma ferramenta chamada de Caos Monkey. Essas ferramenta derruba os servidores e analisa como o sistema se comporta para verificar se tudo é robusto. Isso é um aspecto muito esquecido nas aplicações e cada vez mais determinante na entrega.</p>

<p>Tenho um caso de um sistema muito bem feito, com testes, boa arquitetura, etc, que falhou vergonhasamente quando foi para produção pois esqueceram de configurar o cache corretamente. Pensar nisso é ter a visão holística de que tanto falam diversos autores.</p>

<h2>Ferramentas para ajudar</h2>

<p>Uma grande ferramenta sem dúvida são os testes automatizados. Outra tão boa quanto são aquelas que &ldquo;medem&rdquo; diversos parametros, com frequencia de sua base de código, como: dependência ciclomática; duplicidade de código; aderência a convenções de código (Pep8 para python, JSLint, CodeStyle para Java, etc); analise de perfomance; tolerância a falhas; etc.</p>

<p>Ter um servidor de CI (integração contínua) rodando essas ferramentas, testes, e outras coisas que sejam importantes para o time, é uma grande coisa a ser feita. Coloque alertas, encha a caixa de email do pessoal com mensagens de alerta e obriguem a todos terem carinho com o &ldquo;build&rdquo;. No time agradeço a presença do meu amigo Vinícius que me lembra e nos cobra coisa como essas.</p>

<h2>No final &hellip;</h2>

<p>No final o que mais importa é termos a disciplina e obstinação de sempre buscarmos a melhora contínua do que fazemos. Novas formas, padrões, teorias irão surgir, novas linguagens e ferramentas irão surgir. Porém sempre caberá a nós a busca por fazer nosso trabalhar melhor do que do dia anterior. Esse é o compromisso que quero assumir comigo e com meu trabalho.</p>

<p>Eu não sou um exemplo e nem desejo ser modelo, mas nem por isso devemos acreditar que só os melhores e somente em projetos de &ldquo;empresas legais&rdquo; que isso será possível. Faça aos poucos, se comprometa em fazer diferente. Faça e conquiste seu espaço, os resultados irão te ajudar a provar o valor de tais práticas.</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/01/braziljs/">Braziljs</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-01T11:43:00-03:00" pubdate data-updated="true">Sep 1<span>st</span>, 2012</time>
        
           | <a href="/blog/2012/09/01/braziljs/#disqus_thread"
             data-disqus-identifier="http://andrefonseca.net/blog/2012/09/01/braziljs/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Gostaria de começar esse review do evento BrazilJS dizendo que ele superou em muito a minhas expectativas. Passado o tumulto inicial para a credenciais, que foi resolvido pelo pessoal da organização,  o evento entrou numa crescente de qualidade e excelência.</p>

<p>Não quero fazer uma análise ou &ldquo;crítica&rdquo; ou resumo sobre cada palestra: isso seria injusto com quem está lendo e com o evento. Acredito, verdadeiramente, que houve uma mensagem maior trazida pela soma do todo e essa mensagem seria perdida se tratasse cada apresentação de forma isolada.</p>

<p>Por mais que, já claro até no nome, o evento fosse focado em Javascript, todo o conteúdo de frontend foi abordado e tratado de forma brilhante e, coroada, com a palestra do Bernard de Luna sobre performance no uso de CSS. Além disso, conseguiu, novamente com maestria na escolha dos temas, fugir do lugar comum, onde falar de frontend se limita a falar de páginas e portais. Falamos até de jogos e processamento de imagens.</p>

<p>Como citei acima, a grande linha guia, em minha opinião, foi sem dúvida a evolução e maturidade. É um fato, comprovado pelos participantes e palestrantes, que a comunidade evolui e amadureceu. Estamos mais conscientes de nosso papel na qualidade do que se tem feito nos projetos, estamos mais maduros quanto ao uso de boas práticas, estamos mais alertas quanto a questão &ndash; antes nem pensadas &ndash; de performance, estamos enxergando seu uso além de simples manipulações de DOM, etc. E a linguagem Ecmascript (nome &ldquo;científico&rdquo; do Javascript) parece refletir tudo isso, conforme apresentado brilhantemente pela seu criador.</p>

<p>Javascript não é mais &ldquo;tecnologia&rdquo; secundária. HTML e CSS não são mais maus necessários para entregarmos nossos webapps (que digo o JSF &ndash; trolei !!!!) .
Javascript acencionou ao status de grande linguagem, se colocando lado a lado com JAVA, C#, Python, Ruby, entre outras. Busca a maturidade e resolver seus problemas. Busca o que há de melhor nas outras e dá seu &ldquo;tempero&rdquo;. Python me pareceu o grande irmão mais velho.</p>

<p>Seu uso vai além e se mostra uma excelente opção para automatização de tarefas &ndash; GruntJS,  jogos, manipulação de imagens, tracking, testes, etc.</p>

<p>O frontend não quer e nem se limita mais ao browser e computadores. Busca as fronteiras onde estão os telefones, smartphones e até TVs. Não falo da TV Digital, e sim da TV como meio de consumo de webapps.</p>

<p>Enfim, o evento mostrou de existe um universo a ser explorado lá fora e muito trabalho a ser feito. Mostrou também que a comunidade está forte e capacitada para  desbravá-lo.</p>

<p>Obrigado a todos.</p>
</div>
  
  

</article>

<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
    </div>
  </div>
  <footer role="contentinfo">Copyright &copy; 2014

    Andre Fonseca

<br>
Powered by Octopress.

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'blogandrefonseca';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




</body>
</html>
