--- 
layout: post
title: Usando using no seu codigo C#
tags: 
- .NET
- "Inform\xC3\xA1tica"
- Sem categoria
status: publish
type: post
published: true
meta: {}

---
Um outro dia estava eu e um amigo discutindo sobre linguagem e acabamos por falar sobre a questão do C# possuir o "using".  Ele é uma das coisas interessantes que o C# tem em relação a outras da mesma familia (como Java).
Para começar é preciso entender que o using tem 2 possiveis usos:
	<li>criar um apeliado (alias) para um namespace, e assim facilitar o uso das classe dentro dele</li>
        <li>importar as classes de um determinado namespace; algo parecido com o import do java</li>
Um outro uso possível e bem util do keyword é o seguinte: Imaginemos a situação que você tem um Reader de arquivo e vai efetuar a leitura do conteudo:
<code>
StreamReader reade = new StreamReader("teste.txt");
//vou ler o arquivo agora...
string msg = "";
while(!reader.EndOfStream)
{
      msg << reader.ReadLine();
      cliente.Incremment();
}
reader.Close();
</code>
Bom nesse caso, tudo funciona ok... entretanto imagine o caso da classe cliente, por exemplo, ser nula, ou seu metodo de incremment dispare uma exceção. O sistema irá sair do bloco de codigo e não vai fechar o reader. Isso pode gerar diversos problemas futuros como lock do arquivo e etc. Para resolver isso, muitos diriam - "coloca o bloco de codigo dentro de uma estrutura try catch finally". Excelente, vamos lá:
<code>
try
{
   StreamReader reade = new StreamReader("teste.txt");
   //vou ler o arquivo agora...
   string msg = "";
   while(!reader.EndOfStream)
   {
      msg << reader.ReadLine();
      cliente.Incremment();
   }
    reader.Close();
}
catch(...)
{
}
finally
{
   reader.Close(); // e quaisquer outros tratamentos
}
</code>
O código acima garante a robustez, mas, pelo menos para mim, o código fica muito "poluído". Vamos agora ver um outro uso do using:
<code>
using (StreamReader reade = new StreamReader("teste.txt"))
{
   //vou ler o arquivo agora...
   string msg = "";
   while(!reader.EndOfStream)
   {
         msg << reader.ReadLine();
         cliente.Incremment();
   }
}
</code>
Fazendo isso, o interpretador, ao final garantirá o close do Reader. Isso também é valido para Connections (conexão com o banco de dados por exemplo). Isso deixa o codigo bem elegante. Outra coisa que esta clasula garante que o tempo de vida da classe é somente da execução do bloco, ou seja, ele realizará o dispose do objeto assim que terminar ou sair do bloco. Isso ajuda bastante a evitar os memory leaks e deixar seu codigo super elegante e perfomante.
Aos poucos vou colocar mais tutoriais como este e sobre outras linguagens. Caso tenham duvida podem mandar email ou deixar comentário que tento responder por email ou por meio de um post.
