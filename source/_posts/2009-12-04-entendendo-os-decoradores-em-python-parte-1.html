--- 
layout: post
title: Entendendo os decoradores em Python - Parte 1
tags: 
- "avan\xC3\xA7ado"
- codigo
- decoradores
- python
status: publish
type: post
published: true
meta: 
  _edit_last: "1"
---
A um certo tempo atrás me deparei com alguns códigos que usavam o recurso de decorator.  Dali, curioso com tal coisa, resolvi pesquisar para entender melhor como funcionam, para que servem, e quais seriam bons cenários para usá-lo.

Para minha surpresa, achei pouco material e a maioria dos conteúdos que tratavam do assunto eram superficiais. Outros que abordavam mais a prática (ou associada a um problema único), alguns falavam de forma extremamente complexa, etc. Além de tudo isso, quase nenhum dos artigos eram em português: o tema é complicado e sem fluência no inglês a coisa tende a piorar.

Como recompensa ao esforço a determinação, achei um excelente texto (fonte altamente confiável): <a href="http://www.bruceeckel.com/">Bruce Ecke</a>l, no site <a href="http://www.artima.com/weblogs/">Artima</a>.  O artigo aborda justamente de forma abrangente o assunto, decorator do python, e dando o enfoque que procurava (funcionamento, porque usar, como usar, quando usar) .  Então, como forma de dar minha retribuição a comunidade, segue uma versão do texto dele (não é uma tradução, parte irei reproduzir, outras colocarei minha visão).

Primeira coisa que considero interessante, que o está no texto próprio original,  é que necessitamos desfazer alguns conceitos erróneos sobre Decoradores. Muita gente quando escuta decorators logo remete seu pensamento aos padrões de projeto, mais precisamente, o padrão Decorator.  Esse padrão é feito para possibilidade de forma simples adicionar  recursos, detalhes, adornos a uma classe, inclusive em tempo de execução. Aqui eles tem mais uma carinha de Macros, do que decoradores.

O objetivo das macros é de permitir alterar os elementos de uma linguagem. Isto é exatamente oque os decoradores em Python fazem - eles modificam  funções e classes inteiras (existem decorators para classes) .  Isso é porque eles usualmente provem um caminho alternativo ao uso de metaclass.

A grande parte das linguagens que suportam tal recurso (auto-modificação)  falham no quesito complexidade :  elas são tanto restritivas e requerem, em alguns casos, uma linguagem diferente. Python se faz a pergunta: porque não fazê-lo em python mesmo? Porque não permitir escrever macros ou decoradores na própria linguagem permitindo uma interação maior ? Esse é exatamente a proposta dos decoradores.
<h2>Porque usar Decorators?</h2>
Decorators permitem que se altere a execução de um método ou classe. Para que os conhecem, lembra bastante o AOP (Aspect Oriented Programming - programação orientada a aspecto) .  A diferença que não precisamos muitas coisas ou grandes conhecimentos, oque torna muito interessante e legal, mesmo que para iniciantes.

Um exemplo de uso, didático,  é escrever algo que permita fazer algo antes e depois da execução de uma função.

[cc lang="Python"]
@meuDecorator
def funcaoQualquer():
print "Ola Mundo"

[/cc]
A clásula acima @, define a chamada ao meu decorator que irá fazer algo, quando este método for chamado.  Algo semelhante a uma proxy.(veja mais sobre a sintaxe clicando <a href="http://www.python.org/dev/peps/pep-0318/" title="PEP318" target="_blank">aqui</a>)
